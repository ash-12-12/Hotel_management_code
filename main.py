# -*- coding: utf-8 -*-
"""hotel_chat.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KyWMBcWm9lCXU1U0sGcnq8M-5T2NkNxW
"""

# Update the import statement to include ToolMessage and AnyMessage from langchain_core.messages
from typing import TypedDict, Annotated, Any
from langchain.schema import SystemMessage, HumanMessage, AIMessage # Remove AnyMessage from here
from langchain_core.messages import ToolMessage, AnyMessage # Import ToolMessage and AnyMessage from langchain_core.messages
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.tools import tool
from langgraph.graph import StateGraph, END
import operator
import sqlite3
from langgraph.checkpoint.sqlite import SqliteSaver


# ─── Booking model & tools ────────────────────────────────────────────────────────
from pydantic import BaseModel
from typing import Optional
import time


class Booking(BaseModel):
    user_id: Optional[str] = None
    name: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    checkin: Optional[str] = None
    checkout: Optional[str] = None
    room_type: Optional[str] = None
    guests: Optional[int] = None
    status: Optional[str] = None

# In-memory store of bookings
bookings: dict[str, Booking] = {}




# Tool to create a new booking for a given user ID
@tool
def create_booking(user_id: str) -> str:
    """Create a new booking and return the booking ID."""
    bookings[user_id] = Booking()
    return "Booking created, but not yet confirmed. Please provide your name, email, phone, checkin, checkout, room_type, guests, status."
@tool
def update_booking(user_id: str, property: str, value: str) -> str:
    """Update a property of a booking for a given booking ID. Only enter details that are explicitly provided."""
    booking = bookings[user_id]
    setattr(booking, property, value)
    return f"Booking ID {user_id} updated with {property} = {value}"

@tool
def get_booking_state(user_id: str) -> str:
    """Get the current state of a booking for a given booking ID."""
    try:
        return str(bookings[user_id].dict())
    except:
        return f"Booking ID {user_id} not found"

# Tool to confirm a booking after verifying all required details
@tool
def confirm_booking(user_id: str) -> str:
    """Confirm a booking for a given booking ID."""
    booking = bookings[user_id]

    if booking.name is None:
        raise ValueError("Please provide your name.")
    if booking.email is None:
        raise ValueError("Please provide your email.")
    if booking.phone is None:
        raise ValueError("Please provide your phone number.")
    if booking.checkin is None:
        raise ValueError("Please provide the checkin date of your booking.")
    if booking.checkout is None:
        raise ValueError("Please provide the checkout date of your booking.")
    if booking.room_type is None:
        raise ValueError("Please provide the room type of your booking.")
    if booking.guests is None:
        raise ValueError("Please provide the number of guests of your booking.")
    if booking.status is None:
        raise ValueError("Please provide the status of your booking.")

    return f"Booking ID {user_id} confirmed!"

@tool
def reschedule_booking(user_id: str, new_checkin: str, new_checkout: str) -> str:
    """Reschedule an existing booking when user provides new checkin or checkout."""
    if user_id not in bookings:
        return f"Booking ID {user_id} not found"
    bookings[user_id].checkin = new_checkin
    bookings[user_id].checkout = new_checkout
    return f"Booking {user_id} rescheduled: checkin={new_checkin}, checkout={new_checkout}"

@tool
def hotel_info(question: str) -> str:
    """
    Provides hotel info: amenities, check-in/out, location, etc., using a SQLite table lookup.
    """
    try:
        question = question.lower()
        cursor = conn.cursor()

        if "amenities" in question or "facilities" in question or "features" in question:
            cursor.execute("SELECT content FROM hotel_info WHERE type = 'amenity'")
        elif "check-in" in question or "check-out" in question or "policy" in question or "rules" in question:
            cursor.execute("SELECT content FROM hotel_info WHERE type = 'policy'")
        elif "location" in question or "address" in question or "where" in question:
            cursor.execute("SELECT content FROM hotel_info WHERE type = 'location'")
        else:
            return "Sorry, I couldn't understand your question."

        row = cursor.fetchone()
        return row[0] if row else "No information found."
    except Exception as e:
        return f"Error retrieving hotel info: {e}"



# ─── Agent State & Model Setup ───────────────────────────────────────────────────
class AgentState(TypedDict):
    messages: Annotated[list[AnyMessage], operator.add]

# Initialize LLM
llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-flash",
    temperature=0.2,
    top_p=0.95,
    google_api_key="AIzaSyCXRG2RsDH6XPUMGi453UlYKFawnG8EdX4"
)

# Define Agent with tool execution
class Agent:
    def __init__(self, model, tools, checkpointer, system=""):
        self.system = system
        graph = StateGraph(AgentState)
        graph.add_node("llm", self.call_llm)
        graph.add_node("action", self.take_action)
        graph.add_conditional_edges("llm", self.exists_action, {True: "action", False: END})
        graph.add_edge("action", "llm")
        graph.set_entry_point("llm")
        self.graph = graph.compile(checkpointer=checkpointer)
        self.tools = {t.name: t for t in tools}
        self.model = model.bind_tools(tools)

    def exists_action(self, state: AgentState) -> bool:
        return bool(state["messages"] and getattr(state["messages"][-1], "tool_calls", []))

    def call_llm(self, state):
        msgs =  state["messages"]
        max_retries = 3
        for attempt in range(max_retries):
            try:
                ai_msg = self.model.invoke(msgs)
                return {"messages": [ai_msg]}
            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"LLM error (attempt {attempt+1}), retrying...")
                    time.sleep(1)
                else:
                    # Final failure: wrap in ToolMessage to return control
                    err = ToolMessage(tool_call_id="llm_error", name="LLM", content=f"LLM failed: {e}")
                    return {"messages": [err]}

    def take_action(self, state: AgentState) -> dict:
        last = state["messages"][-1]
        results = []
        for call in last.tool_calls:
            name, args = call["name"], call["args"]
            try:
                res = self.tools[name].invoke(args)
            except Exception as e:
                res = f"Error calling {name}: {e}"
            results.append(ToolMessage(tool_call_id=call["id"], name=name, content=str(res)))
        return {"messages": results}

# ─── Initialization ──────────────────────────────────────────────────────────────
conn = sqlite3.connect("chat_memory.db", check_same_thread=False)
memory = SqliteSaver(conn=conn)
tools = [create_booking, update_booking, get_booking_state, confirm_booking, reschedule_booking, hotel_info]
user = "user123"
system_prompt = (
    f"You are now connected to the booking system for {user}. "
    "Only use tools when prompted and only include provided details."
)
abot = Agent(llm, tools, checkpointer=memory, system=system_prompt)

def process_message_from_instagram(user_id: str, text: str) -> str:
    from langchain.schema import HumanMessage
    config = {"configurable": {"thread_id": user_id}}
    messages = [HumanMessage(content=text)]
    try:
        responses = []
        for event in abot.graph.stream({"messages": messages}, config):
            for node_out in event.values():
                for msg in node_out["messages"]:
                    responses.append(msg.content)
        return "\n".join(responses)
    except Exception as e:
        return f"Error processing your request: {e}"

