# -*- coding: utf-8 -*-
"""hotel_chat.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KyWMBcWm9lCXU1U0sGcnq8M-5T2NkNxW
"""

# Update the import statement to include ToolMessage and AnyMessage from langchain_core.messages
from typing import TypedDict, Annotated, Any
from langchain.schema import SystemMessage, HumanMessage, AIMessage # Remove AnyMessage from here
from langchain_core.messages import ToolMessage, AnyMessage # Import ToolMessage and AnyMessage from langchain_core.messages
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.tools import tool
from langgraph.graph import StateGraph, END
import operator
import sqlite3
from langgraph.checkpoint.sqlite import SqliteSaver

# ─── Booking model & tools ────────────────────────────────────────────────────────
from pydantic import BaseModel
from typing import Optional


class Booking(BaseModel):
    user_id: Optional[str] = None
    name: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    checkin: Optional[str] = None
    checkout: Optional[str] = None
    room_type: Optional[str] = None
    guests: Optional[int] = None
    status: Optional[str] = None

# In-memory store of bookings
bookings: dict[str, Booking] = {}

# Tool to create a new booking for a given user ID
@tool
def create_booking(user_id: str) -> str:
    """Create a new booking and return the booking ID."""
    bookings[user_id] = Booking()
    return "Booking created, but not yet confirmed. Please provide your name, email, phone, checkin, checkout, room_type, guests, status."
@tool
def update_booking(user_id: str, property: str, value: str) -> str:
    """Update a property of a booking for a given booking ID. Only enter details that are explicitly provided."""
    booking = bookings[user_id]
    setattr(booking, property, value)
    return f"Booking ID {user_id} updated with {property} = {value}"

@tool
def get_booking_state(user_id: str) -> str:
    """Get the current state of a booking for a given booking ID."""
    try:
        return str(bookings[user_id].dict())
    except:
        return f"Booking ID {user_id} not found"

# Tool to confirm a booking after verifying all required details
@tool
def confirm_booking(user_id: str) -> str:
    """Confirm a booking for a given booking ID."""
    booking = bookings[user_id]

    if booking.name is None:
        raise ValueError("Please provide your name.")
    if booking.email is None:
        raise ValueError("Please provide your email.")
    if booking.phone is None:
        raise ValueError("Please provide your phone number.")
    if booking.checkin is None:
        raise ValueError("Please provide the checkin date of your booking.")
    if booking.checkout is None:
        raise ValueError("Please provide the checkout date of your booking.")
    if booking.room_type is None:
        raise ValueError("Please provide the room type of your booking.")
    if booking.guests is None:
        raise ValueError("Please provide the number of guests of your booking.")
    if booking.status is None:
        raise ValueError("Please provide the status of your booking.")

    return f"Booking ID {user_id} confirmed!"

@tool
def reschedule_booking(user_id: str, new_checkin: str, new_checkout: str) -> str:
    """Reschedule an existing booking when user provides new checkin or checkout."""
    if user_id not in bookings:
        return f"Booking ID {user_id} not found"
    bookings[user_id].checkin = new_checkin
    bookings[user_id].checkout = new_checkout
    return f"Booking {user_id} rescheduled: checkin={new_checkin}, checkout={new_checkout}"


# ─── Agent State & Model Setup ───────────────────────────────────────────────────
class AgentState(TypedDict):
    messages: Annotated[list[AnyMessage], operator.add]

# Initialize LLM
llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-flash",
    temperature=0.2,
    top_p=0.95,
    google_api_key="AIzaSyCXRG2RsDH6XPUMGi453UlYKFawnG8EdX4"
)

# Define Agent with tool execution
class Agent:
    def __init__(self, model, tools, checkpointer, system=""):
        self.system = system
        graph = StateGraph(AgentState)
        graph.add_node("llm", self.call_llm)
        graph.add_node("action", self.take_action)
        graph.add_conditional_edges("llm", self.exists_action, {True: "action", False: END})
        graph.add_edge("action", "llm")
        graph.set_entry_point("llm")
        graph.set_finish_point("llm")  # ✅ signal clean termination
        self.graph = graph.compile(checkpointer=checkpointer)
        self.tools = {t.name: t for t in tools}
        self.model = model.bind_tools(tools)

    def exists_action(self, state: AgentState) -> bool:
        return bool(state["messages"] and getattr(state["messages"][-1], "tool_calls", []))

    def call_llm(self, state: AgentState) -> dict:
        msgs = state["messages"]
        if self.system:
            msgs = [SystemMessage(content=self.system)] + msgs
        ai_msg = self.model.invoke(msgs)
        return {"messages": [ai_msg]}

    def take_action(self, state: AgentState) -> dict:
        last = state["messages"][-1]
        results = []
        for call in last.tool_calls:
            name, args = call["name"], call["args"]
            try:
                res = self.tools[name].invoke(args)
            except Exception as e:
                res = f"Error: {e}"
            results.append(ToolMessage(tool_call_id=call["id"], name=name, content=str(res)))
        return {"messages": results}

# ─── Initialization ──────────────────────────────────────────────────────────────
conn = sqlite3.connect("chat_memory.db", check_same_thread=False)
memory = SqliteSaver(conn=conn)
tools = [create_booking, update_booking, get_booking_state, confirm_booking, reschedule_booking]
user = "user123"
system_prompt = (
    f"You are now connected to the booking system for {user}. "
    "Only use tools when prompted and only include provided details."
)
abot = Agent(llm, tools, checkpointer=memory, system=system_prompt)

# ─── Example driver ──────────────────────────────────────────────────────────────
if __name__ == "__main__":
    messages = [HumanMessage(content="I want to book a room")]
    config = {"configurable": {"thread_id": "1"}}

    for event in abot.graph.stream({"messages": messages}, config):
        for node_out in event.values():
            for msg in node_out["messages"]:
                print(f"{type(msg).__name__}: {msg.content}")

messages = [HumanMessage(content="checkin : 8/24/2025 and checkout : 9/24/2025")]
config = {"configurable": {"thread_id": "1"}}

for event in abot.graph.stream({"messages": messages}, config):
    for node_out in event.values():
        for msg in node_out["messages"]:
            print(f"{type(msg).__name__}: {msg.content}")

pip install langchain chromadb sentence-transformers

from langchain_community.embeddings import SentenceTransformerEmbeddings

# Use the 'avsolatorio/GIST-Embedding-v0' model trained for similarity tasks
gist_model = SentenceTransformerEmbeddings(model_name="avsolatorio/GIST-Embedding-v0")

# Update the import statement to include ToolMessage and AnyMessage from langchain_core.messages
from typing import TypedDict, Annotated, Any
from langchain.schema import SystemMessage, HumanMessage, AIMessage # Remove AnyMessage from here
from langchain_core.messages import ToolMessage, AnyMessage # Import ToolMessage and AnyMessage from langchain_core.messages
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.tools import tool
from langgraph.graph import StateGraph, END
import operator
import sqlite3
from langgraph.checkpoint.sqlite import SqliteSaver
from langchain.vectorstores import Chroma

# ─── Booking model & tools ────────────────────────────────────────────────────────
from pydantic import BaseModel
from typing import Optional
import time


class Booking(BaseModel):
    user_id: Optional[str] = None
    name: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    checkin: Optional[str] = None
    checkout: Optional[str] = None
    room_type: Optional[str] = None
    guests: Optional[int] = None
    status: Optional[str] = None

# In-memory store of bookings
bookings: dict[str, Booking] = {}

from langchain.schema import Document

docs = [
    Document(
        page_content="Our address is 123 Main Street, Central Bengaluru, near MG Road metro station.",
        metadata={"type": "location"}
    ),
    Document(
        page_content="Standard check-in is between 2 PM and 3 PM; check-out by 12 PM noon.",
        metadata={"type": "policy"}
    ),
    Document(
        page_content="We offer free high‑speed Wi‑Fi, complimentary breakfast, a gym, indoor pool, room service, spa, and on-site parking.",
        metadata={"type": "amenity"}
    ),
]

vector_db = Chroma.from_documents(
    documents=docs,
    embedding=gist_model,  # use encode directly
    persist_directory="./hotel_gist_db"
)

# Tool to create a new booking for a given user ID
@tool
def create_booking(user_id: str) -> str:
    """Create a new booking and return the booking ID."""
    bookings[user_id] = Booking()
    return "Booking created, but not yet confirmed. Please provide your name, email, phone, checkin, checkout, room_type, guests, status."
@tool
def update_booking(user_id: str, property: str, value: str) -> str:
    """Update a property of a booking for a given booking ID. Only enter details that are explicitly provided."""
    booking = bookings[user_id]
    setattr(booking, property, value)
    return f"Booking ID {user_id} updated with {property} = {value}"

@tool
def get_booking_state(user_id: str) -> str:
    """Get the current state of a booking for a given booking ID."""
    try:
        return str(bookings[user_id].dict())
    except:
        return f"Booking ID {user_id} not found"

# Tool to confirm a booking after verifying all required details
@tool
def confirm_booking(user_id: str) -> str:
    """Confirm a booking for a given booking ID."""
    booking = bookings[user_id]

    if booking.name is None:
        raise ValueError("Please provide your name.")
    if booking.email is None:
        raise ValueError("Please provide your email.")
    if booking.phone is None:
        raise ValueError("Please provide your phone number.")
    if booking.checkin is None:
        raise ValueError("Please provide the checkin date of your booking.")
    if booking.checkout is None:
        raise ValueError("Please provide the checkout date of your booking.")
    if booking.room_type is None:
        raise ValueError("Please provide the room type of your booking.")
    if booking.guests is None:
        raise ValueError("Please provide the number of guests of your booking.")
    if booking.status is None:
        raise ValueError("Please provide the status of your booking.")

    return f"Booking ID {user_id} confirmed!"

@tool
def reschedule_booking(user_id: str, new_checkin: str, new_checkout: str) -> str:
    """Reschedule an existing booking when user provides new checkin or checkout."""
    if user_id not in bookings:
        return f"Booking ID {user_id} not found"
    bookings[user_id].checkin = new_checkin
    bookings[user_id].checkout = new_checkout
    return f"Booking {user_id} rescheduled: checkin={new_checkin}, checkout={new_checkout}"

@tool
def hotel_info(question: str) -> str:
    """
    Provides hotel info: amenities, check-in/out, location, etc.
    """
    try:
        hits = vector_db.similarity_search(question, k=2)
        return "\n".join([doc.page_content for doc in hits]) if hits else "No info found."
    except Exception as e:
        return f"Error retrieving hotel info: {e}"


# ─── Agent State & Model Setup ───────────────────────────────────────────────────
class AgentState(TypedDict):
    messages: Annotated[list[AnyMessage], operator.add]

# Initialize LLM
llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-flash",
    temperature=0.2,
    top_p=0.95,
    google_api_key="AIzaSyCXRG2RsDH6XPUMGi453UlYKFawnG8EdX4"
)

# Define Agent with tool execution
class Agent:
    def __init__(self, model, tools, checkpointer, system=""):
        self.system = system
        graph = StateGraph(AgentState)
        graph.add_node("llm", self.call_llm)
        graph.add_node("action", self.take_action)
        graph.add_conditional_edges("llm", self.exists_action, {True: "action", False: END})
        graph.add_edge("action", "llm")
        graph.set_entry_point("llm")
        self.graph = graph.compile(checkpointer=checkpointer)
        self.tools = {t.name: t for t in tools}
        self.model = model.bind_tools(tools)

    def exists_action(self, state: AgentState) -> bool:
        return bool(state["messages"] and getattr(state["messages"][-1], "tool_calls", []))

    def call_llm(self, state):
        msgs =  state["messages"]
        max_retries = 3
        for attempt in range(max_retries):
            try:
                ai_msg = self.model.invoke(msgs)
                return {"messages": [ai_msg]}
            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"LLM error (attempt {attempt+1}), retrying...")
                    time.sleep(1)
                else:
                    # Final failure: wrap in ToolMessage to return control
                    err = ToolMessage(tool_call_id="llm_error", name="LLM", content=f"LLM failed: {e}")
                    return {"messages": [err]}

    def take_action(self, state: AgentState) -> dict:
        last = state["messages"][-1]
        results = []
        for call in last.tool_calls:
            name, args = call["name"], call["args"]
            try:
                res = self.tools[name].invoke(args)
            except Exception as e:
                res = f"Error calling {name}: {e}"
            results.append(ToolMessage(tool_call_id=call["id"], name=name, content=str(res)))
        return {"messages": results}

# ─── Initialization ──────────────────────────────────────────────────────────────
conn = sqlite3.connect("chat_memory.db", check_same_thread=False)
memory = SqliteSaver(conn=conn)
tools = [create_booking, update_booking, get_booking_state, confirm_booking, reschedule_booking, hotel_info]
user = "user123"
system_prompt = (
    f"You are now connected to the booking system for {user}. "
    "Only use tools when prompted and only include provided details."
)
abot = Agent(llm, tools, checkpointer=memory, system=system_prompt)

# ─── Example driver ──────────────────────────────────────────────────────────────
if __name__ == "__main__":
    messages = [HumanMessage(content="I want to book a room")]
    config = {"configurable": {"thread_id": "1"}}
    try:
      for event in abot.graph.stream({"messages": messages}, config):
        for node_out in event.values():
            for msg in node_out["messages"]:
                print(f"{type(msg).__name__}: {msg.content}")
    except Exception as e:
        print(f"Fatal error in agent execution: {e}")

messages = [HumanMessage(content="I want to know location of hotel")]
config = {"configurable": {"thread_id": "1"}}
try:
  for event in abot.graph.stream({"messages": messages}, config):
    for node_out in event.values():
        for msg in node_out["messages"]:
            print(f"{type(msg).__name__}: {msg.content}")
except Exception as e:
    print(f"Fatal error in agent execution: {e}")

